# 아키텍처 개요

이 문서는 IaaS 플랫폼의 기술 스택, 현재 아키텍처 및 향후 발전 방향에 대해 설명합니다.

## 1. 핵심 기술 스택

- **언어**: Python 3
- **백엔드**: 순수 WSGI
- **데이터베이스**: SQLite (SQLAlchemy ORM 사용)
- **가상화**: KVM/QEMU 및 libvirt-python
- **개발 환경**: Vagrant와 VirtualBox (중첩 가상화)

## 2. 계층형 아키텍처 (Layered Architecture)

현재 프로젝트는 유지보수성과 확장성을 극대화하기 위해 명확한 계층형 아키텍처를 따릅니다. 각 계층은 지정된 역할만 수행하며, 의존성은 항상 상위 계층에서 하위 계층으로 단방향으로 흐릅니다.

```
+------------------+      +--------------------+      +--------------------------+
|    API Layer     |----->|   Service Layer    |----->|   Repository Interface   |
|     (app.py)     |      | (Business Logic)   |      |        (Contract)        |
+------------------+      +--------------------+      +--------------------------+
                                                            ^
                                                            | (implements)
                                                            |
+------------------+      +----------------------+      +--------------------------+
| Database (SQLite)|<-----| SQLAlchemy ORM Core  |<-----|  SQLAlchemy Repository   |
+------------------+      +----------------------+      |     (Implementation)     |
                                                            +--------------------------+
```

### 2.1. API Layer (`app.py`)

- **역할**: HTTP 요청을 수신하고 응답을 반환하는 최상위 계층입니다.
- **책임**: 요청 파싱, 인증, 기본 유효성 검사 및 적절한 서비스 호출을 담당합니다. 또한, 의존성 주입(Dependency Injection)의 시작점으로서, 각 요청에 필요한 서비스와 리포지토리 인스턴스를 생성하고 연결합니다.

### 2.2. Service Layer (`src/services/`)

- **역할**: 애플리케이션의 핵심 비즈니스 로직을 수행합니다.
- **책임**: 여러 리포지토리나 다른 서비스들을 조합하여 하나의 완전한 기능 단위를 구현합니다. (예: `ComputeService`의 VM 생성 로직)
- **특징**: 이 계층은 데이터베이스의 존재나 구현 기술(SQLAlchemy 등)에 대해 전혀 알지 못합니다. 오직 리포지토리 **인터페이스**에만 의존합니다.

### 2.3. Repository Layer (`src/repositories/`)

- **역할**: 데이터 영속성(Persistence)을 처리하는 유일한 계층으로, 데이터베이스 접근을 추상화합니다.
- **책임**:
    - **Interfaces (`interfaces/`)**: 데이터 접근을 위한 계약(Contract)을 정의합니다. (`IVMRepository` 등) 서비스 계층은 이 인터페이스에만 의존합니다.
    - **Implementations (`sqlalchemy/`)**: 인터페이스의 실제 구현부를 작성합니다. SQLAlchemy를 사용하여 DB와 상호작용하는 모든 코드가 여기에 포함됩니다.
- **특징**: 나중에 데이터베이스를 SQLite에서 PostgreSQL로 바꾸고 싶다면, 이 구현체만 새로 작성하면 됩니다. 서비스 계층 코드는 전혀 수정할 필요가 없습니다.

### 2.4. Data Model Layer (`src/database/models/`)

- **역할**: 데이터베이스 테이블의 구조를 파이썬 클래스로 정의합니다.
- **책임**: SQLAlchemy의 ORM 모델을 사용하여 테이블, 컬럼, 관계 등을 코드로 명시합니다. 이 모델들은 리포지토리 구현체에서 사용됩니다.

## 3. 🧐 아키텍처 검토 및 비판

현재 프로젝트의 아키텍처를 검토했을 때, 향후 확장성을 위해 고려해야 할 주요 사항들입니다.

1.  **견고성 부족: 롤백(Rollback) 로직 부재**
    -   **현황**: VM 생성 또는 삭제 과정 중 중간에 실패하면, 일부 리소스(디스크 파일, libvirt 정의 등)가 그대로 남아 시스템에 쓰레기 데이터가 쌓입니다.
    -   **위험성**: 이런 '고아 리소스'들은 향후 다른 작업에 예기치 않은 충돌을 일으킬 수 있습니다.
    -   **개선 방향**: 모든 작업 단계를 트랜잭션(Transaction)처럼 관리하여, 실패 시 이전 상태로 되돌리는 롤백 로직을 추가해야 합니다.

2.  **성능 한계: 동기(Synchronous) 처리 방식**
    -   **현황**: VM 생성처럼 시간이 오래 걸리는 작업을 요청하면, 완료될 때까지 API가 응답을 주지 않고 계속 기다립니다.
    -   **위험성**: 사용자가 많아지면 서버의 가용 스레드가 모두 고갈되어 새로운 요청을 처리하지 못하는 상태가 될 수 있습니다.
    -   **개선 방향**: 로드맵에 있듯이, RabbitMQ 같은 메시지 큐를 도입하여 오래 걸리는 작업은 백그라운드에서 비동기적으로 처리하도록 구조를 변경해야 합니다.

3.  **비효율적인 목록 조회: N+1 문제**
    -   **현황**: `list_vms`는 DB에서 N개의 VM을 조회한 뒤, 각 VM의 상태를 확인하기 위해 N번의 libvirt API를 추가로 호출합니다.
    -   **위험성**: VM의 개수가 많아지면 `GET /v1/vms` API의 응답 속도가 급격히 느려집니다.
    -   **개선 방향**: `self.conn.listAllDomains()` 같은 함수로 libvirt의 모든 VM 상태를 **한 번에** 가져온 후, DB에서 가져온 정보와 메모리상에서 합치는 방식으로 리팩토링하여 API 호출 횟수를 줄여야 합니다. (리포지토리 패턴 덕분에, 이 로직은 `ComputeService`를 수정하지 않고도 개선할 수 있습니다.)